(ns hoplon.ui
  (:refer-clojure :exclude [range time floats])
  (:refer-hoplon  :exclude [body button elem form rt font])
  (:require-macros
    [hoplon.ui :as r])
  (:require
    [clojure.string :refer [split]]
    [clojure.set    :refer [rename-keys]]
    [hoplon.ui.value :refer [ev rt px kw ratio? value? dom]]))

;;; constants ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(def empty-icon-url  "data:;base64,iVBORw0KGgo=")
(def empty-image-url "data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==")

(def ^:dynamic *data*   nil)
(def ^:dynamic *error*  nil)
(def ^:dynamic *submit* nil)

(def +sm+ 736)
(def +lg+ 1069)

(def +default-button+      {:color 0xffffff :s-color 0xcccccc :font-color 0x333})
(def +default-button-down+ {:color 0xd4d4d4 :s-color 0x8c8c8c :font-color 0x333})
(def +primary-button+      {:color 0x337ab7 :s-color 0x2e6da4 :font-color 0xfff})
(def +primary-button-down+ {:color 0x286090 :s-color 0x204d74 :font-color 0xfff})
(def +success-button+      {:color 0x5cb85c :s-color 0x4cae4c :font-color 0xfff})
(def +success-button-down+ {:color 0x449d44 :s-color 0x398439 :font-color 0xfff})
(def +warning-button+      {:color 0xf0ad4e :s-color 0xeea236 :font-color 0xfff})
(def +warning-button-down+ {:color 0xd58512 :s-color 0x985f0d :font-color 0xfff})
(def +info-button+         {:color 0x5bc0de :s-color 0x46b8da :font-color 0xfff})
(def +info-button-down+    {:color 0x31b0d5 :s-color 0x269abc :font-color 0xfff})
(def +danger-button+       {:color 0xd9534f :s-color 0xd43f3a :font-color 0xfff})
(def +danger-button-down+  {:color 0xac2925 :s-color 0x761c19 :font-color 0xfff})

(def +success+ {:color 0xdff0d8 :s-color 0xd6e9c6 :font-color 0x3c763d})
(def +warning+ {:color 0xfcf8e3 :s-color 0xfaebcc :font-color 0x8a6d3b})
(def +danger+  {:color 0xf2dede :s-color 0xebccd1 :font-color 0xa94442})
(def +info+    {:color 0xd9edf7 :s-color 0xBCE8F1 :font-color 0x31708f})

(def palettes
  {:hoplon.ui/success +success+
   :hoplon.ui/warning +warning+
   :hoplon.ui/danger  +danger+
   :hoplon.ui/info    +info+})

(def +f+  21)
(def +p+  18)

(def +sc+ 0xCCC)

(def bgcolor :grey)

(def globals [:initial :inherit])

(def lengths [:auto])

(def colors [:transparent :antiquewhite :aqua :aquamarine :azure :beige :bisque :black
             :blanchedalmond :blue :blueviolet :brown :burlywood :cadetblue :chartreuse
             :chocolate :coral :cornflowerblue :cornsilk :crimson :darkblue :darkcyan
             :darkgoldenrod :darkgray :darkgreen :darkgrey :darkkhaki :darkmagenta
             :darkolivegreen :darkorange :darkorchid :darkred :darksalmon :darkseagreen
             :darkslateblue :darkslategray :darkslategrey :darkturquoise :darkviolet
             :deeppink :deepskyblue :dimgray :dimgrey :dodgerblue :firebrick :floralwhite
             :forestgreen :fuchsia :gainsboro :ghostwhite :gold :goldenrod :gray :green
             :greenyellow :grey :honeydew :hotpink :indianred :indigo :ivory :khaki
             :lavender :lavenderblush :lawngreen :lemonchiffon :lightblue :lightcoral
             :lightcyan :lightgoldenrodyellow :lightgray :lightgreen :lightgrey :lightpink
             :lightsalmon :lightseagreen :lightskyblue :lightslategray :lightslategrey
             :lightsteelblue :lightyellow :lime :limegreen :linen :maroon :mediumaquamarine
             :mediumblue :mediumorchid :mediumpurple :mediumseagreen :mediumslateblue
             :mediumspringgreen :mediumturquoise :mediumvioletred :midnightblue :mintcream
             :mistyrose :moccasin :navajowhite :navy :oldlace :olive :olivedrab :orangered
             :orchid :palegoldenrod :palegreen :paleturquoise :palevioletred :papayawhip
             :peachpuff :peru :pink :plum :powderblue :purple :rebeccapurple :red
             :rosybrown :royalblue :saddlebrown :salmon :sandybrown :seagreen :seashell
             :sienna :silver :skyblue :slateblue :slategray :slategrey :snow :springgreen
             :steelblue :tan :teal :thistle :tomato :turquoise :violet :wheat :white
             :whitesmoke :yellow :yellowgreen])

(def cursors [:alias :all-scroll :auto :cell :context-menu :col-resize :copy
              :crosshair :default :e-resize :ew-resize :grab :grabbing :help :move :n-resize
              :ne-resize :nesw-resize :ns-resize :nw-resize :nwse-resize :no-drop :none
              :not-allowed :pointer :progress :row-resize :s-resize :se-resize :sw-resize
              :text :vertical-text :w-resize :wait :zoom-in :zoom-out])

(def decorations [:none :underline :overline :line-through])
(def styles      [:normal :italic :oblique])
(def weights     [:normal :bold :bolder :lighter :number])
(def kernings    [:auto :normal :none])

(def haligns [:left :right :center :justify])
(def valigns [:top :middle :bottom :baseline :sub :super :text-top :text-bottom])

(def floats    [:left :right])
(def overflows [:visible :hidden :scroll :auto])

;;; utils ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defn split-if [str re]
  (if str (split str re)))

(defn subs-if [str start end]
  (if str (subs str start end)))

(defn route->hash [[path & [qmap]]]
  "transforms a urlstate of the form [[\"foo\" \"bar\"] {:baz \"barf\"}]
   to hash string in the form \"foo/bar&baz=barf\""
  (let [pair (fn [[k v]] (str (name k) "=" (pr-str v)))
        pstr (when path (apply str "/" (interpose "/" (map name path))))
        qstr (when qmap (apply str "?" (interpose "&" (map pair qmap))))]
    (str "#" pstr qstr)))

(defn hash->route [hash]
  "transforms a hash string to a urlstate of the form
   [[\"foo\" \"bar\"] {:baz \"barf\"}]"
  (let [[rstr qstr] (split (subs hash 2) #"\?")
        pair        #(let [[k v] (split % #"=")] [(keyword k) (cljs.reader/read-string v)])
        qmap        (->> (split qstr #"&") (map pair) (when (not-empty qstr)) (into {}))
        path        (->> (split rstr #"/") (remove empty?) (mapv keyword))]
    (vec (remove empty? [path qmap]))))

(def visibility->status
  "maps the visibility string to a status keyword"
  {"visible"   :foreground
   "hidden"    :background
   "prerender" :background
   "unloaded"  :terminated})

(def parse-args #'hoplon.core/parse-args)

(defn ->px    [v]  (if (number? v) (str v "px") v))

;;; validators ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defn namekw [v & kws]
  (if (some #{v} (apply concat kws))
      (name v)
      (throw (js/Error. (str "Keyword value " v " invalid.")))))

(defn string [v]
  (if (or (= (subs v (- (count v) 1) (count v)) "%")
          (= (subs v (- (count v) 2) (count v)) "em"))
      v
      (throw (js/Error. (str "String value " v " invalid.")))))

;; todo: rgb colors
(defn ->color [v]
  (cond
    (nil?     v) "initial"
    (keyword? v) (namekw v colors globals)
    (number?  v) (str "#" (.toString v 16))
    :else        (throw (js/Error. (str "Color value " v " invalid.")))))

(defn ->len [v]
  (cond
    (nil?     v) "auto"
    (list?    v) (let [[op x y] v] (str "calc(" (->len x) " " op " " (->len y) ")"))
    (integer? v) (str    v "px")
    (number?  v) (str (* v 100) "%")
    (keyword? v) (namekw v lengths globals)
    (string?  v) (string v)
    :else        (throw (js/Error. (str "Length value " v " invalid.")))))

(defn ->cursor [v]
  (cond
    (nil?     v) "initial"
    (keyword? v) (namekw v cursors globals)
    :else        (throw (js/Error. (str "Cursor value " v " invalid.")))))

(defn ->decoration [v]
  (cond
    (nil?     v) "initial"
    (keyword? v) (namekw v decorations globals)
    :else        (throw (js/Error. (str "Decoration value " v " invalid.")))))

(defn ->style [v]
  (cond
    (nil?     v) "initial"
    (keyword? v) (namekw v styles globals)
    :else        (throw (js/Error. (str "Style value " v " invalid.")))))

(defn ->weight [v]
  (cond
    (nil?     v) "initial"
    (keyword? v) (namekw v weights globals)
    (integer? v)  v
    :else        (throw (js/Error. (str "Weight value " v " invalid.")))))

(defn ->halign [v]
  (cond
    (nil?     v) "initial"
    (keyword? v) (namekw v haligns globals)
    :else        (throw (js/Error. (str "Align value " v " invalid.")))))

(defn ->overflow [v]
  (cond
    (nil?     v) "initial"
    (keyword? v) (namekw v overflows globals)
    :else        (throw (js/Error. (str "Overflow value " v " invalid.")))))

(defn ->valign [v]
  (cond
    (nil?     v) "initial"
    (integer? v) (str    v "px")
    (number?  v) (str    v "%")
    (keyword? v) (namekw v valigns globals)
    (string?  v) (string  v)
    :else        (throw (js/Error. (str "Vertical align value " v " invalid.")))))

(defn ->font-family [v]
  (cond
    (nil?     v) "initial"
    (keyword? v) (namekw v globals)
    (string?  v) v
    :else        (throw (js/Error. (str "Font family value " v " invalid.")))))

;;; box model ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(def out-attrs
  {:css/box-sizing     "border-box"    ;; include border and padding in dimensions
   :css/display        "inline-table"  ;; layout ltr ttb when width not 100% to support responsive design
   :css/vertical-align "top"           ;; inline-block/table elems must be explititly told to align themselves to the top
   :css/text-align     "initial"})     ;; prevent inheritance of alignment from parent

(def mid-attrs
  {:css/box-sizing "border-box" ;; include border and padding in dimensions
   :css/display    "table-cell" ;; cells in tables enable sane vertical alignment
   ;:css/width      "inherit"    ;  assume the width of the parent and proxy it to the inner div
   ;:css/overflow   "scroll"
   :css/height     "inherit"})  ;; assume the height of the parent and proxy it to the inner div

(def in-attrs
  {:css/display    "block"      ;; prevent white space from creeping in around inline elements
   :css/position   "relative"   ;; make positioned children adjust relative to container plus padding
  ; :css/width      "inherit"    ;; prevent children with absolute widths from expanding width of parent
   :css/height     "inherit"})  ;; display block fills the width, but needs to be told to fill the height (unless vertical alignment is set)

(defn box-xf [ctr & [inv]]
  "implements the box model by evaluating the element constructor and wrapping
   it in two additional divs. attributes are filtered out and applied to the
   middle and outer divs as appropriate, with the remaining attributes being
   passed to the original element constructor."
  (fn [attrs elems]
    (->> elems
         ((if inv div ctr) in-attrs)
         (div              mid-attrs)
         ((if inv ctr div) out-attrs))))

;;; utils ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defn out [e] e)
(defn mid [e] (-> e .-firstChild))
(defn in  [e] (-> e .-firstChild .-firstChild))

(defn throw-ui! [elem msg]
  (let [error-msg (str "UI ERROR: " msg)]
    (set! (.. elem -title) error-msg)
    (set! (.. elem -style -border) "4px dotted red")
    (println error-msg)))

(defn set-value! [elem f k v] ;; todo: mult vs to reduce # of cells
  (let [e (f elem)]
    (cond (nil?     v) identity
          (cell?    v) (do-watch v #(set-value! elem f k %2))
          (integer? v) (aset e "style" k (dom (px v)))
          (value?   v) (aset e "style" k (dom v))
          :else        (throw-ui! elem (str "Attribute \"" k "\" has an invalid value of \"" v "\".")))))

(defn set-style! [e f k v]
  (cond (ifn?  e) (set-value! e f k v)
        (coll? e) (doseq [e e] (set-style! e f k v))
        (cell? e) (do-watch e #(set-style! @e f k v))
        :else     e))

;;; attributes ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;; todo:
;; shadow
;; cursor
;; margin
;; fixed
;; constraint (absolute positioning within parent)
;; offset     (use outer css margin to move out of current position)
;; todo, once clear cases become apparent
;; baseline-shift
;; background, url (str "url(" v ") no-repeat 50% 50% / cover")
;; user-select, selectable
;; :toggle as as mid-attr
;; update, previously implemented on do multimethod, to form middleware

(defn align [ctor]
  "set the text-align and vertical-align attributes on the elem and proxy the
   vertical-align attribute to the outer element of each child.  set vertical
   height of the inner element to auto when the align vertical attribute is set.

  the vertical alignment is proxied to the outer elements of the children so
  that, in addition to aligning the lines of children within the elem, the
  children are also aligned in the same manner within their respective lines."
  (fn [{:keys [ah av] :as attrs} elems]
    (doseq [elem elems]
      (set-style! elem out "vertical-align" av))
    (with-let [e (ctor (dissoc attrs :ah :av) elems)]
      (set-style! e in  "height"         (cell= (if av :auto :inherit))) ;; initial instead?
      (set-style! e mid "text-align"     ah)
      (set-style! e mid "vertical-align" av))))

(defn color [ctor]
  "set the background color an the inner element."
  (fn [{:keys [c o] :as attrs} elems]
    (with-let [e (ctor (dissoc attrs :c :o) elems)]
      (set-style! e mid "background-color" c)
      (set-style! e mid "opacity"          o))))

(defn overflow [ctor]
  "set the overflow style on the elem's middle element."
  (fn [{:keys [v vh vv :as attrs elems]}]
    (with-let [e (ctor (dissoc attrs :v :vh :vv) elems)]
      (set-style! e mid "overflow-x" (cell= (or vh v)))
      (set-style! e mid "overflow-y" (cell= (or vv v))))))

(defn pad [ctor]
  "set the padding on the elem's inner element.

   this adds space between the edges of the container and its children."
  (fn [{:keys [p pl pr pt pb ph pv] :as attrs} elems]
    (with-let [e (ctor (dissoc attrs :p :pl :pr :pt :pb :ph :pv) elems)]
      (set-style! e in "padding-left"   (cell= (or pl ph p)))
      (set-style! e in "padding-right"  (cell= (or pr ph p)))
      (set-style! e in "padding-top"    (cell= (or pt pv p)))
      (set-style! e in "padding-bottom" (cell= (or pb pv p))))))

(defn round [ctor]
  "set the radius on the middle element."
  (fn [{:keys [r rtl rtr rbl rbr] :as attrs} elems]
    (with-let [e (ctor (dissoc attrs :r :rtl :rtr :rbl :rbr) elems)]
      (set-style! e mid "border-top-left-radius"     (cell= (or rtl r)))
      (set-style! e mid "border-top-right-radius"    (cell= (or rtr r)))
      (set-style! e mid "border-bottom-left-radius"  (cell= (or rbl r)))
      (set-style! e mid "border-bottom-right-radius" (cell= (or rbr r))))))

(defn size [ctor]
  "set the size on the outer element when it is expressed as a ratio, and on the
   inner element when it is a length.

   since ratios are expressed in terms of the parent, they include the margin
   (implemented as the padding between the inner and outer elements). fixed
   lengths are set on the middle, however, to exclude the margin so that when a
   margin is added, it will push out against the parent container instead of
   being subtracted from the size of the elem."
  (fn [{:keys [w w- w+ h h- h+] :as attrs} elems]
    (with-let [e (ctor (dissoc attrs :w :w- :w+ :h :h- :h+) elems)]
      (let [f #(if (ratio? %) out mid)]
        (set-style! e (f w)  "width"  w)
        (set-style! e (f w-) "width"  w-)
        (set-style! e (f w+) "width"  w+)
        (set-style! e (f h)  "height" h)
        (set-style! e (f h-) "height" h-)
        (set-style! e (f h+) "height" h+)))))

(defn space [ctor]
  "set the padding on the outer element of each child and a negative margin on
   the inner element of the elem itself equal to the padding.

   outer padding on the children creates an even gutter between them, while the
   negative inner margin on the elem itself offsets this padding to fencepost
   the children flush with the edges of the container."
  (fn [{:keys [g gh gv] :as attrs} elems]
    (let [mh (cell= (/ (or gh g) 2))
          mv (cell= (/ (or gh g) 2))
          ph (cell= (- mh))
          pv (cell= (- mv))]
      (doseq [elem elems]
        (set-style! elem out "padding-left"   mh)
        (set-style! elem out "padding-right"  mh)
        (set-style! elem out "padding-top"    mv)
        (set-style! elem out "padding-bottom" mv))
      (with-let [e (ctor (dissoc attrs g gh gv) elems)]
        (set-style! e in "margin-left"   ph)
        (set-style! e in "margin-right"  ph)
        (set-style! e in "margin-top"    pv)
        (set-style! e in "margin-bottom" pv)))))

(defn stroke [ctor]
  "set the border on the elem's middle element.

   this adds space between the edges of the container and its children."
  (fn [{:keys [s sl sr st sb sh sv sc scl scr sct scb sch scv] :as attrs} elems]
    (with-let [e (ctor (dissoc attrs :s :sl :sr :st :sb :sh :sv :sw :scl :scr :sct :scb :sch :scv) elems)]
      (set-style! e mid "border-left-width"   (cell= (or sl sh s)))
      (set-style! e mid "border-left-color"   (cell= (or scl sch sc)))
      (set-style! e mid "border-left-style"   (cell= (when (or sl sh s) :solid)))
      (set-style! e mid "border-right-width"  (cell= (or sr sh s)))
      (set-style! e mid "border-right-color"  (cell= (or scr sch sc)))
      (set-style! e mid "border-right-style"  (cell= (when (or sr sh s) :solid)))
      (set-style! e mid "border-top-width"    (cell= (or st sv s)))
      (set-style! e mid "border-top-color"    (cell= (or sct scv sc)))
      (set-style! e mid "border-top-style"    (cell= (when (or st sv s) :solid)))
      (set-style! e mid "border-bottom-width" (cell= (or sb sv s)))
      (set-style! e mid "border-bottom-color" (cell= (or scb scv sc)))
      (set-style! e mid "border-bottom-style" (cell= (when (or sb sv s) :solid))))))

(defn font [ctor]
  "set the text styles pertaining to the attribute"
  (fn [{:keys [f fw fh ft ff fc fu fi fm fk] :as attrs} elems]
    (with-let [e (ctor (dissoc attrs :f :fw :fh :ft :ff :fc :fu :fi :fm :fk) elems)]
      (set-style! e mid "font-size"       f)
      (set-style! e mid "letter-spacing"  fw)
      (set-style! e mid "line-height"     fh)
      (set-style! e mid "font-weight"     ft)
      (set-style! e mid "font-family"     ff)
      (set-style! e mid "color"           fc)
      (set-style! e mid "text-decoration" fu)
      (set-style! e mid "font-style"      fi)
      (set-style! e mid "font-smooth"     fm)
      (set-style! e mid "font-kerning"    fk))))

;;; containers ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defn box [ctr & args]
  (apply (-> ctr box-xf font align size pad color stroke round space) (parse-args args)))

(defelem body [attrs elems]
  ((-> hoplon.core/body (box-xf :invert) font align size pad color stroke round space) attrs elems))

(defelem elem [attrs elems]
  (box div attrs elems))

(defelem form* [{:keys [submit] :as attrs} elems]
  (let [elem (elem (dissoc attrs :submit) elems)
        data *data*]
    (reset! *submit* submit)
    (.keypress (js/jQuery elem) #(if (= (.-which %) 13) (submit @data)))
    elem))

;;; element primitives ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defelem anchor [{:keys [url] :as attrs} elems]
  (box
    (hoplon.core/a
      :html/href   url
      :html/target "_blank")
    (dissoc attrs :url)
    elems))

(defelem button [{:keys [prompt] :as attrs} elems]
  (box
    (hoplon.core/button
      :css/width            "100%"
      :css/background-color "transparent"
      :css/border-style     "none"
      :css/text-align       "inherit")
      ;:css/outline          "none"
    :pr         12
    :ph         14
    :pv         10
    :r          4
    :color      0xFFF
    :s          1
    :s-color    0xCCC
    :ah         :center
    :font-size  +p+
    :font-color 0x333
    :cursor     :pointer
    (dissoc attrs :prompt)
    (cons prompt elems)))

(defelem image [{:keys [label url] :as attrs} _]
  (box
    (hoplon.core/img ;; implement using css, bg image instead to make a container, or make image outer div?
      :css/width "100%"
      :html/src  (cell= (or url empty-image-url))
      :html/alt  label)
    ; :w        :auto
    :overflow :hidden
   (dissoc attrs :label :url)))

;;; forms ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defelem checkbox [{:keys [name label prompt selected g] :as attrs} _]
  (box
    (hoplon.core/label
      (hoplon.core/input
        :type               "checkbox"
        :name               name
        :checked            selected
        :css/margin-right   (->px (or g 8))
        :css/vertical-align "text-bottom")
      (or prompt label))
    (dissoc attrs :name :label :selected)))

(defelem field* [{:keys [autocorrect autocapitalize name label prompt type value] :as attrs} _]
  (box
    (hoplon.core/input
      :css/width            "100%"
      :css/background-color "transparent"
      :css/box-shadow       "none"
      :css/border-style     "none"
      :css/padding          "0"
      :css/font-size        "inherit"
      ; :css/outline          "none"
      :name                 name
      :type                 type
      :value                value
      :placeholder          prompt
      :autocorrect          autocorrect
      :autocapitalize       autocapitalize)
    :ph        14
    :pv        10
    :r         4
    :s         1
    :s-color   0xCCC
    :color     0xFFF
    :font-size +p+
    (dissoc attrs :name :type :value :prompt :autocorrect :autocapitalize)))

(defelem field [{:keys [valid] :as attrs} _]
  (let [field-name  #(.attr (js/jQuery (.-target %)) "name")
        field-value #(.val (js/jQuery (.-target %)))
        elem        (field* (dissoc attrs :valid))
        data        *data*]
    (.change (js/jQuery elem) #(prn :data (when data @data) (keyword (field-name %)) (field-value %)))
    (.change (js/jQuery elem) #(when data (swap! data assoc (keyword (field-name %)) (field-value %))))
    (.keyup  (js/jQuery elem) #(when data (swap! data assoc (keyword (field-name %)) (field-value %))))
    elem))

(defelem dropdown [{:keys [name options prompt] :as attrs} _]
  (let [state (cell :closed)
        index (cell nil)]
    (.click (js/jQuery js/document) #(reset! state :closed))
    (button
      :click #(do (.stopPropagation %) (reset! index (aget (.data (js/jQuery (.-target %))) "index")) (reset! state (if (= @state :closed) :open :closed)))
      :ah           :left
      :pr           26
      :name         name
      :prompt       (cell= (or (and index (nth options index)) prompt))
      (dissoc attrs :name :options :prompt)
      (div
        :css/position     "absolute"
        :css/display      "inline-block"
        :css/width        "0"
        :css/height       "0"
        :css/right        "18px"
        :css/top          "50%"
        :css/margin-top   "-2px"
        :css/border-top   "5px dashed"
        :css/border-right "5px solid transparent"
        :css/border-left  "5px solid transparent")
      (ul
        :toggle               (cell= (= state :open))
        :css/position         "absolute"
        :css/float            "left"
        :css/top              "100%"
        :css/left             "0"
        :css/min-width        "98%"
        :css/margin           "0"
        :css/padding-left     "6px"
        :css/padding-right    "6px"
        :css/z-index          "1000"
        :css/border-style     "solid"
        :css/border-width     "1px"
        :css/border-radius    "4px"
        :css/border-color     "#CCC"
        :css/background-color "#FFF"
        :css/list-style       "none"
        (for-tpl [[i v] (cell= (map-indexed vector options))]
          (li :css/margin-left "0" :css/padding "6px" :data-index i (text v)))))))

(defelem submit [{:keys [submit] :as attrs} elems]
  (let [subm *submit*
        data *data*]
    (button :click #((or submit @subm) @data) (dissoc attrs :submit) elems)))

; (defelem checkbox       [attrs _] (field (merge {:type "checkbox"}       attrs)))
; (defelem color          [attrs _] (field (merge {:type "color"}          attrs)))
(defelem date           [attrs _] (field (merge {:type "date"}           attrs)))
(defelem datetime       [attrs _] (field (merge {:type "datetime"}       attrs)))
(defelem datetime-local [attrs _] (field (merge {:type "datetime-local"} attrs)))
(defelem email          [attrs _] (field (merge {:type "email"}          attrs)))
(defelem file           [attrs _] (field (merge {:type "file"}           attrs)))
(defelem hidden         [attrs _] (field (merge {:type "hidden"}         attrs)))
#_(defelem image          [attrs _] (field (merge {:type "image"}          attrs)))
(defelem month          [attrs _] (field (merge {:type "month"}          attrs)))
(defelem number         [attrs _] (field (merge {:type "number"}         attrs)))
(defelem radio          [attrs _] (field (merge {:type "radio"}          attrs)))
(defelem range          [attrs _] (field (merge {:type "range"}          attrs)))
(defelem reset          [attrs _] (field (merge {:type "reset"}          attrs)))
(defelem search         [attrs _] (field (merge {:type "search"}         attrs)))
(defelem telephone      [attrs _] (field (merge {:type "tel"}            attrs)))
(defelem time           [attrs _] (field (merge {:type "time"}           attrs)))
(defelem url            [attrs _] (field (merge {:type "url"}            attrs)))
(defelem week           [attrs _] (field (merge {:type "week"}           attrs)))
(defelem password       [attrs _] (field (merge {:type "password"}       attrs)))
(defelem username       [attrs _] (field (merge {:type "text" :autocorrect "off" :autocapitalize "off"} attrs)))

;; todo: window rel=noopener
;; todo: finish mousechanged

(defelem window [{:keys [alert metadata route scroll scripts styles initiated mousechanged scrollchanged statuschanged routechanged] :as attrs} elems]
  (let [get-agent  #(-> js/window .-navigator)
        get-hash   #(-> js/window .-location .-hash)
        get-route  #(-> js/window .-location .-hash hash->route)
        get-status #(-> js/window .-document .-visibilityState visibility->status)]
    (when initiated
      (initiated (get-route) (get-status) (get-agent)))
    (when routechanged
      (.addEventListener js/window "hashchange"
        #(when-not (= (route->hash @route) (get-hash)) (routechanged (get-route)))))
    (when statuschanged
      (.addEventListener js/window "visibilitychange"
        #(statuschanged (get-status))))
    (when scrollchanged
       (.addEventListener js/window "scroll"
         #(let [[x y :as new-scroll] (vector (.-scrollX js/window) (.-scrollY js/window))]
            (when-not (= new-scroll scroll)
              (scrollchanged x y)))))
    (cell= (set! js/location.hash (route->hash route)))
    (.addEventListener js/document "DOMContentLoaded"
      #(cell= (.scroll js/window (first scroll) (second scroll)))))
  (html :lang (:lang attrs "en") :css/height "100%"
    (head
      (html-meta :charset "utf-8")
      (html-meta :http-equiv "X-UA-Compatible" :content "IE=edge")
      (html-meta :name "viewport"    :content "width=device-width, initial-scale=1")
      (for [m (if (map? metadata) (map (fn [[k v]] {:name k :content v}) metadata) metadata)]
        (html-meta (into {} (for [[k v] m] [k (name v)]))))
      (title (:title attrs))
      (link :rel "icon" :href (or (:icon attrs) empty-icon-url))
      (for-tpl [s styles]  (link :rel "stylesheet" :href s))
      (for-tpl [s scripts] (script :src s)))
    (body :h (rt 1 1) :w (rt 1 1) :css/margin 0 :css/font-family "Helvetica Neue, Helvetica, Arial, sans-serif" ;; font-size 100%, neutralize body dflts
      (dissoc attrs :alert :scroll :metadata :title :icon :route :lang :styles :scripts :initiated :mousechanged :scrollchanged :statuschanged :routechanged)
      elems)))

;;; element components ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defelem alert [{:keys [alert] :as attrs} _]
  (let [detail  (cell false)
        palette #(palettes (keyword "hoplon.ui" (name (or (:severity %) "info"))))]
    (elem
      :ph         15
      :pv         10
      :r          4
      :s          2
      :toggle     alert
      :color      (cell= (:color      (palette alert)))
      :s-color    (cell= (:s-color    (palette alert)))
      :font-color (cell= (:font-color (palette alert)))
      (dissoc attrs :alert)
      (cell= (:message alert)))))
